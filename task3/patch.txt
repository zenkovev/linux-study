diff --git a/fs/proc/base.c b/fs/proc/base.c
index dd31e3b6b..751434acc 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -486,6 +486,26 @@ static int proc_pid_schedstat(struct seq_file *m, struct pid_namespace *ns,
 
 	return 0;
 }
+
+/*
+ * MIPT 1C Linux Course
+ * Task 3: Processes: task_struct
+ */
+/*
+ * Provides /proc/PID/schedcount
+ */
+static int proc_pid_schedcount(struct seq_file *m, struct pid_namespace *ns,
+			      struct pid *pid, struct task_struct *task)
+{
+	if (unlikely(!sched_info_on())) {
+		seq_puts(m, "0\n");
+	} else {
+		int sched_count = atomic64_read(&task->sched_count);
+		seq_printf(m, "%d\n", sched_count);
+	}
+
+	return 0;
+}
 #endif
 
 #ifdef CONFIG_LATENCYTOP
@@ -3304,6 +3324,11 @@ static const struct pid_entry tgid_base_stuff[] = {
 #endif
 #ifdef CONFIG_SCHED_INFO
 	ONE("schedstat",  S_IRUGO, proc_pid_schedstat),
+	/*
+	 * MIPT 1C Linux Course
+	 * Task 3: Processes: task_struct
+	 */
+	ONE("schedcount",  S_IRUGO, proc_pid_schedcount),
 #endif
 #ifdef CONFIG_LATENCYTOP
 	REG("latency",  S_IRUGO, proc_lstats_operations),
@@ -3653,6 +3678,11 @@ static const struct pid_entry tid_base_stuff[] = {
 #endif
 #ifdef CONFIG_SCHED_INFO
 	ONE("schedstat", S_IRUGO, proc_pid_schedstat),
+	/*
+	 * MIPT 1C Linux Course
+	 * Task 3: Processes: task_struct
+	 */
+	ONE("schedcount",  S_IRUGO, proc_pid_schedcount),
 #endif
 #ifdef CONFIG_LATENCYTOP
 	REG("latency",  S_IRUGO, proc_lstats_operations),
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 292c31697..ed1969213 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1544,6 +1544,12 @@ struct task_struct {
 	struct user_event_mm		*user_event_mm;
 #endif
 
+	/*
+	 * MIPT 1C Linux Course
+	 * Task 3: Processes: task_struct
+	 */
+	atomic64_t sched_count;
+
 	/*
 	 * New fields for task_struct should be added above here, so that
 	 * they are included in the randomized portion of task_struct.
diff --git a/kernel/fork.c b/kernel/fork.c
index 10917c3e1..c36345109 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -2332,6 +2332,13 @@ __latent_entropy struct task_struct *copy_process(
 	p = dup_task_struct(current, node);
 	if (!p)
 		goto fork_out;
+
+	/*
+	 * MIPT 1C Linux Course
+	 * Task 3: Processes: task_struct
+	 */
+	atomic64_set(&p->sched_count, 0);
+
 	p->flags &= ~PF_KTHREAD;
 	if (args->kthread)
 		p->flags |= PF_KTHREAD;
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index a708d225c..ab25ce6ee 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -6720,6 +6720,12 @@ static inline void sched_submit_work(struct task_struct *tsk)
 	 */
 	lock_map_acquire_try(&sched_map);
 
+	/*
+	 * MIPT 1C Linux Course
+	 * Task 3: Processes: task_struct
+	 */
+	atomic64_add(1, &tsk->sched_count);
+
 	task_flags = tsk->flags;
 	/*
 	 * If a worker goes to sleep, notify and ask workqueue whether it
